先在开头总结一下，二叉树解题的思维模式分两类：

1、**是否可以通过遍历一遍二叉树得到答案？**如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式
2、**是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？**如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式

无论使用哪种思维模式，你都需要思考：
**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？**其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作

### 二叉树的重要性

举个例子，比如两个经典排序算法 快速排序 和 归并排序，对于它俩，你有什么理解？

**如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了**

二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题

### 深入理解前中后序

1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？
2、请分析，后序遍历有什么特殊之处？
3、请分析，为什么多叉树没有中序遍历？

先不管所谓前中后序，单看 traverse 函数，你说它在做什么事情？
```go
func traverse(root *TreeNode) {
    if root == nil {
        return
    }
    // 前序位置
    traverse(root.Left)
    // 中序位置
    traverse(root.Right)
    // 后序位置
}
```
其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：
```go
// 迭代遍历数组
func traverse(arr []int) {
    for i:=0; i<len(arr); i++ {

    }
}

// 递归遍历数组
func traverse(arr []int, i int) {
    if i == len(arr) {
        return
    }
    // 前序位置
    traverse(arr, i+1)
    // 后序位置
}

// 迭代遍历单链表
func traverse(head *ListNode) {
    for p:=head; p!=nil; p=p.Next {

    }
}

// 递归遍历单链表
func traverse(head *ListNode) {
    if head == nil {
        return
    }
    // 前序位置
    traverse(head.Next)
    // 后序位置
}
```
单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式

你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后

所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

比如说，如果让你倒序打印一条单链表上所有节点的值，你怎么搞？
```go
// 递归遍历单链表，倒序打印链表元素
func traverse(head *ListNode) {
    if head == nil {
        return
    }
    traverse(head.Next)
    // 后序位置
    fmt.Println(head.Val)
}
```

结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用递归的堆栈帮你实现了倒序遍历的效果
那么说回二叉树也是一样的，只不过多了一个中序位置罢了

教科书里只会问你前中后序遍历结果分别是什么，所以对于一个只上过大学数据结构课程的人来说，他大概以为二叉树的前中后序只不过对应三种顺序不同的 List<Integer> 列表

但是我想说，**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：
前序位置的代码在刚刚进入一个二叉树节点的时候执行；
后序位置的代码在将要离开一个二叉树节点的时候执行；
中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行

你注意本文的用词，我一直说前中后序「位置」，就是要和大家常说的前中后序「遍历」有所区别：
你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事

**你可以发现每个节点都有「唯一」属于自己的前中后序位置**，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点

这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置

说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：
**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**

### 两种解题思路

**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架**

力扣第 104 题「二叉树的最大深度」

你做这题的思路是什么？显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，**这就是遍历二叉树计算答案的思路**
当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来，**这就是分解问题计算答案的思路**

综上，遇到一道二叉树的题目时的通用思考过程是：
1、**是否可以通过遍历一遍二叉树得到答案？**如果可以，用一个 traverse 函数配合外部变量来实现。
2、**是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？**如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。
3、**无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**

### 后序位置的特殊之处

**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：
1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？
2、如何打印出每个节点的左右子树各有多少节点？

这两个问题的根本区别在于：
**一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去**
**而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案**

结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息
**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**

### 以树的视角看动归/回溯/DFS算法的区别和联系

动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：
- 动态规划算法属于分解问题的思路，它的关注点在整棵「子树」
- 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」
- DFS 算法属于遍历的思路，它的关注点在单个「节点」

### 层序遍历

层序遍历属于迭代遍历
